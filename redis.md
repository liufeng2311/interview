### Redis的知识结构

 * 知识结构
        
        线程模型、淘汰策略、过期机制、持久化方式、数据结构、功能应用、集群部署   
        
 * 参考链接
        
        http://www.redis.cn/documentation.html   官网
        https://aobing.blog.csdn.net/article/details/103041932  博客
        https://www.cnblogs.com/javazhiyin/p/13839357.html 博客
    
### 缓存

 * 为什么使用缓存
        
        使用缓存是高并发场景下提高热点数据访问性能的一中有效手段。用以提高系统的响应速度。
        对于关系型数据库,数据是保存在磁盘中的,将数据从磁盘加载至JVM中需要磁盘IO和网络IO,这一过程是耗时的。
        我们可以将热门数据提前加载至JVM中以达到快速调用的效果,这就是缓存。
        
 * 缓存的分类
        
        本地缓存
        
            JVM中的数据可以理解为本地缓存,不需要通过网络IO和磁盘IO就可以通过程序直接获得。
            本地缓存在多个JVM实例间不能互享。
            
        分布式缓存
        
            分布式缓存用来解决多个JVM不能共享内存数据的,比如Redis,不需要进行磁盘IO,只需要经过网络IO。
            多个JVM通过共同访问统一内存实现数据共享。
            
        多级缓存
        
            多级缓存只是一种策略,根据数据的访问频率不同将数据存储在不同的地方,最热门数据存储到本地缓存中,较热门数据存储到
            分布式缓存中,冷门数据存储在关系型数据库中 
          
### Redis

 * 什么是Redis
        
        Redis是基于C编写的高性能非关系型的键值对数据库。与关系型数据库不同,Redis的值是存储在内存中的。
        这就意味着他的读写速度非常的快,官方测试数据为每秒10万次读写操作。
        
 * redis线程模型
        
        Redis的通络通信是用NIO实现的。通过一个多路复用线程来处理接受到的channel请求。
        seleter会将请求暂存起来顺序执行。类似于Netty单线程版本。
        Redis的单线程指的是只有一个线程来处理用户请求,而不是整个redis只有一个线程。
        
        
 * 单线程的redis如何提高CPU的利用率
        
        可以通过部署多个redis实例来提高利用率
        也可以部署其他的服务

 * 为什么Redis的读写速度快
 
        redis的读写是完全基于内存的,数据的读写耗时可以基本定义为网络数据传输的耗时。
        redis的数据结构简单,数据的读写耗时基本可以忽略。
        redis采用单线程的处理机制,避免了单线程的上下文切换。
                 
### 缓存淘汰策略

 * 淘汰策略
        
        基于内存存储数据必定受限于内存大小。
        当剩余内存不足以保存我们的新数据时,需要通过某些策略删除一些数据。这就是数据淘汰策略。
        
 * 常用淘汰策略算法
        
       FIFO : 删除最早存入的数据,实现方式为队列
                
       LRU : 删除最久未使用的数据,实现方式为双向链表
        
       LFU ：删除访问频率最低的数据,实现方式为大顶堆
        
                  
### Redis服务部署

 * 下载redis安装包
 
        Redis官方下载最新版本安装包并上传服务器(https://redis.io/download)
        安装redis的环境(yum install gcc)
        进入解压后的文件进行编译和安装(make & make install)
            
        make :该指令的目的是为了编译redis,生成可执行文件,此时只能在src目录下启动服务(未配置环境变量)
        make install: 将常用命令放至/usr/local/bin目录下,此时可以在系统任何位置启动服务(配置环境变量)
        
 * 单机部署
 
        修改配置文件redis.conf
            
        bind : 设置redis使用的网卡地址,表示外界只有访问该网卡才可以访问redis,可配置多个网卡IP
        port : 设置redis服务的端口
        daemonize : 设置为yes,表示以守护线程启动(后台启动)
        pidfile : 存储redis实例IP,修改为安装包路径即可
        dir : 存储数据的地址,修改为安装包路径即可
        logfile : 日志路径,修改为安装包路径即可
        requirepass : 设置登录密码
        
       开放端口
      
       firewall-cmd --zone=public --add-port=6379/tcp --permanent   开放6379端口
       firewall-cmd --reload  重新加载防火墙规则使配置生效
       
       启动服务
       
       redis-server redis.conf
       
 * 主从复制(主节点出错的话,需要手动切换节点)
 
      修改slave配置文件(单机版基础上)
            
      replicaof IP port   设置replicaof指向master的IP和端口
      masterauth 123456   设置master的密码
      
      从节点只能读不能写,默认是最终一致性(通过参数设置)
      
 * 哨兵模式(所有节点的密码必须是一致的)(主节点出错的话,哨兵完成切换)
 
      哨兵模式是为了弥补主从复制需要手动切换的缺陷,通过哨兵监控完成主从切换,默认配置一主二从三哨兵。
      哨兵中配置了master节点的地址和密码(哨兵从master节点读取slave节点的信息),
      当超过半数以上的哨兵认为master节点宕机了,就修改其中一个slave节点为master节点,
      并修改其他从节点的配置文件指向该master节点
      
      修改配置文件sentinel.conf(主从复制基础上添加哨兵配置)
            
      sentinel monitor master 192.168.0.104 6379 2  指定主节点的IP、端口, 2表示至少两个哨兵同意才能进行故障转移,过半原则,哨兵最少为三个
      sentinel auth-pass master <password>     设置主节点密码
      
 * 集群部署(只有master可以提供读写功能,slave不提供读写功能,只保证高可用)(强一致性)
 
      修改配置文件redis.conf(单机版基础上)
            
            cluster-enabled yes 开启集群
            cluster-node-timeout 5000  超时时间设置为5秒,超过则认为连接失败   
            
      启动所有实例
      创建集群(至少三个master节点)
            
            redis-cli --cluster create IP1:port1 IP2:port2 IP3:port3 IP4:port4 IP5:port5 IP6:port6 --cluster-replicas 1  最后的1表示分配比例,主从按1:1分配,前三个为主机
      查看集群帮助文档
            
            redis-cli --cluster help
      
      客户端连接
            
            redis-cli -h IP -p port -c       -c是redis-cli独有的,可以跳转到对应的服务器
            
### redis的底层数据结构是怎么样的
        
 * 字典
        Redis的数据结构被称为字典,字典时hash算法的一种实现。类似于java中的HashMap。
        
        字典包含了如下字段:
            
            1. 数据的类型
            2. Hash表(两个hash表,一个用于扩容)
            3. 是否在扩容标志
            4. 当前正在运行的安全迭代器数量 
 * String
        
        Redis定义了自己的String类型。类似于java中ArrayLlist,一个String最大为512M。
        内部保存了一个字节数组,在数据改变时不需要重新创建。
        内部保存了字节数组的剩余长度,在数据添加时判断是否需要扩容。
        
        String包含了如下字段:
            
            1.已占用的长度
            2.剩余可用长度
            3.字符数组,保存数据  
            
                
### Redis基本数据类型(五种)
        
 * String
        
        在该类型下,Redis就像一个可以持久化的memcached服务。
                
        redis提供了两个有趣的机制
        
        set key value nx   不存在插入成功 
        set key value xx   已存在插入成功
        
        应用场景:
            1. 保存序列化的用户信息
            2. 计数功能
            3. 分布式锁
        
 * List
        
        List指的是有序元素的集合,Redis通过Linked实现的。是一个双向链表
        
        应用场景：
            
            粉丝列表、文章评论、聊天系统信息、传递消息队列
            
 * Hash
        
        类似与java中的对象,存在多个属性值,不能层级存储
        
        应用场景:
            
            保存对象信息
        
 * Set
        类似java中的set,返回的数据总是无序的
        
        应用场景:
            
            扑克牌游戏的发牌、为数据设置标签、用户的共同好友
            
 * sorted set
        
        为set中的每个元素关联一个分数,用分数实现了排序.
        当分数相同时,会按照元素的字典顺序排序

        应用场景:
            
            各种排行榜
            
 * bitmap
        
        底层为对位操作
        
        应用场景：
            
            布隆过滤器、一段时间内的用户签到情况
            
### Redis持久化

 * Redis持久化
        
        Redis是基于内存的数据库,重启后会造成数据的丢失。因此需要持久化。redis提供了两种持久化方式：
        RDB(Redis DataBase): 指定时间间隔对数据进行快照。
        AOF(Append Only File): 记录每次对服务器写的操作。
        
 * RDB(默认开启)
        
        save 900 1              900秒发生1次变化就保存
        save 300 10             300秒发生10次变化就保存
        save 60  10000          60秒10000次变化就保存
        save ""                 关闭RDB持久化方式
        
 * AOF(默认关闭)
        
        appendfsync always      每个命令都写入
        appendfsync everysec    每秒写入一次
        appendfsync no          关闭AOF持久化方式


 * redis重启如何加载数据
        
        当我们只配置一种持久化方式时,会加载我们配置的文件
        当我们两种都配置时,只会加载AOF中的数据,因为AOF保存的信息总是比RDB全面
        
 * RDB和AOF的比较
        
        RDB相对于AOF来说文件更小,因为RDB是对实时数据的快照,AOF是对命令的拼接。一条数据新增和删除
        在RDB中是体现不出来的,而AOF中会保留下记录。
        AOF相对RDB来说保存的数据更全面,默认只丢失一秒的数据。
        为了解决AOF文件偏大的问题,当文件过大时,后台会触发AOF重写,减小文件的大小

 * 选用哪种持久化方式
        
        最好两个都开启,RDB方便数据的备份,我们可以每天或者每小时进行数据备份
        AOF用以保存完整的数据 
        
### Redis持久化数据和缓存怎么做扩容
 
 * 搭建集群扩容
        
        Redis集群提供了扩容机制,我们可以把没有数据的槽点分配给新的redis服务
    
### 使用redis作为缓存会存在什么问题

 * 数据不一致问题
        
        1.正常情况
            
            正常情况我们先修改数据库,然后更新缓存,这个过程分为三步：
            1. 更新数据
            2. 更新缓存
            
            上述过程中存在如下两种情况:
            1. 更新数据库失败的话,缓存依旧为最新的数据,不会造成数据不一致
            2. 更新数据库成功,更新缓存失败,导致缓存中的数据不正确,造成数据不一致
            
        2. 当数据库更新成功缓存更新失败
            
            为了解决上述问题中的不一致,可以在更新数据库前直接删除缓存再更新数据库再更新缓存

        3. 解决办法
            
            设置一个标志位,当执行增删改操作成功后,设置该标志位为false,当更新缓存后设置为true
            当查询时,只有标志位为true才可以查询,否则自旋
            
 * 高并发下的数据不一致问题
        
         1. 删除缓存再更新数据库再更新缓存会存在如下问题
            
            在并发量高的情况下,可能存在读线程在写线程执行前又把旧的数据缓存起来,所以写线程更新后需要再次删除缓存,
            由下一个读线程更新缓存。
            
 * 缓存穿透(恶意攻击和爬虫)
 
        描述
        
            一直访问数据库不存在的数据,导致缓存失去意义
        解决办法
            
            1、缓存空对象,空对象的过期时间需要根据场景设置,因为该ID可能在之后新增时产生
            2. 做缓存权限验证
            2. 布隆过滤器
 * 缓存击穿
 
        描述
        
            高并发环境下,缓存失效时刚好有大量读线程同时判断出缓存为空会去访问数据库

        解决办法
            
            查询数据库时添加锁
            热点数据永不过期
 * 缓存雪崩
 
        描述
            
            同一时刻,多个缓存过期,导致大量读线程访问数据库。
            
        解决办法
            
            不同的K设置不同的过期时间,通过添加一个随机数来实现
            加锁来保证同时只有一个线程访问数据库
            分布式部署
            
### keys *的弊端

 * 查询        
        keys * 表示遍历所有的数据, 此时会阻塞redis的单线程, 当K值很多时可能导致redis暂时不能处理socket请求
        scan命令不会阻塞,因为是开启新的线程执行的            
        
###  分布式锁的实现

 * Redis为什么支持分布式锁
    
       redis采用单线程的方式处理接收来的请求,所有的请求都是顺序执行的,不存在多线程并发问题
       处理字符串的NX机制可以判断在没有值K的时候才会去创建,正好对应了无锁时进行加锁的机制
       
 * 业务出错无法释放锁如何处理
    
       业务在执行期间发生了意外宕机, 就会导致锁无法释放, 因此我们需要给锁添加一个过期合理的时间。
       该过期时间不能太长, 否则在发生宕机时也会造成长时间无法获取锁。

 * 业务未执行完锁超过了过期时间如何处理
       
       我们需要开启一个新的任务来异步检测当前线程的业务的执行状态, 如果业务还在执行, 则延迟锁的过期时间, 也就是所谓的看门狗机制。

 * 如何防止A线程意外释放B线程锁的问题

       如果代码书写不规范, 就会导致锁被其他线程意外释放的问题。 我们在获取锁时生成一个UUID, 释放锁时传入该UUID, 只有当UUID一致时才释放。
    
 * 若master节点宕机且slave节点没有同步该锁时如何处理
    
       在一台master节点上加锁可能会导致主节点宕机从节点未同步的情况,这样slave变master节点其他请求就能获取到锁了
       处理方式是同时在多台master上加锁,因为多台服务同时宕机的概率极低(过半原则)   
       
 * redLock
        
        RedissonRedLock是redis官方提出的分布式锁实现类,使用与集群环境,在所有的master节点上加锁。
        默认获取失败后没有重试机制。
  
 * key竞争如何解决
        
        当多个JVM对同一个key操作时,如果需要保证有序性,需要通过分布式锁来确保Key的有序性
        
### 过期数据的删除策略

 * Redis中存在过期时间的数据是如何存储的
        
        Redis中存在专门的字典用来保存设置了过期时间的数据
        expires字典的K值保存的是指向键空间某个键的指针,V保存的是过期的具体时间
            
 * Redis如何删除过期的数据
    
        定时删除：设置过期时间时创建一个定时器来删除(对内存非常友好,但是会占用CPU资源)
        定期删除：定期删除过期值,在expires字典中每十秒随机选出20个K进行检测,当过期的数量超过25%,循环该步骤(定期删除)
        惰性删除：获取数据时再判断该数据是否过期,对CPU友好,但是会造成内存浪费

 * Redis采用的何种策略
    
        定期删除 + 惰性删除 + 内存淘汰
 
 * redis如何设置过期时间
        
        expire key time    设置指定时间
        persist key        设置为不过期
        ttl key            查看剩余存活时间
        
### 淘汰策略
    
 * Redis内存大小
        
        maxmemory    该参数指定了redis内存的最大值,该超过该值时,redis如何处理就是所谓的回收算法    
                     设置为0代表没有内存限制。对于64位的系统这是个默认值，对于32位的系统默认内存限制为3GB。
                     
 * 设置淘汰策略
        
        maxmemory-policy       该参数指定了采用哪种算法
        maxmemory-samples 5    设置每次采样数量
        
 * 常用淘汰策略
        
        noeviction         当需要空闲内存时存储数据时返回错误信息
        allkeys-lru        回收最旧未使用的数据 
        volatile-lru       回收最少使用的数据 ,仅在设置了过期时间的数据中进行删除
        allkeys-random     随机回收数据 
        volatile-random    随机回收数据 ,仅在设置了过期时间的数据中进行删除
        volatile-ttl       回收设置了过期时间且剩余存活时间较短的数据 
        
 * Redis的LRU是如何实现的
        
        LRU是Redis唯一支持的回收方法,却不是真正意义上的LRU,而是通过采样的方式LRU
        
        当我们存入新的数据时会判断是否会超过内存限制,超过的话会根据我们设置的回收策略进行回收
        通过我们设置测采样数随机的取出指定数量的数据,根据淘汰策略删除数据
        
### 主从间的数据如何复制

 * slave从master复制数据的逻辑
        
        每个master上都有一个replication ID,标记指定的数据集
        当存在salve时,master会通过offset记录所有的数据
        
        master会保存每个slave已经转移的偏移量,当slave掉线重连后,master会根据已经转移的偏移量进行转移
        replication + offest表示一个集合,记录了数据的多个版本,版本信息存在内存中到达一定值会被清除
        
        slave重连时,如果replication + offest的版本在内存中,只需要转移增量部分, 否则全量转移
        
        
 * 主从复制过程   
        
        1.slave启动后根据配置的master信息与master建立连接
        2.连接建立后发送sync命令给master表示需要同步数据
        3.master接受到命令后根据replication ID和偏移量来判断是进行全量复制还是增量复制
        4.master生成RDB文件发送给slave同时缓存新接受的命令
        5.slave保存RDB文件并加载后,master同步期间接受的新命令给slave
        
 * redis赋值如何处理key的过期(从服务器如何处理过期)
        
        slave不会让key过期，而是等待master让key过期。
        当一个master让一个key到期(或由于LRU算法将之驱逐),它会合成一个DEL命令并传输到所有的slave。
        
 
 * master不开启持久化会存在什么问题,如何解决
        
        当master关闭持久化时,所有的数据只存在内存中,此时重启会会造成数据全部丢失。
        当slave开启持久化时,在master快速重启后,slave检测到master数据为空,会同步master数据造成数据丢失
        
### 实现一个淘汰算法,删除最早添加的元素或者删除最久未被访问的元素

 * LinkedHashMap实现删除最早添加的数据 
        
        LinkedHashMap默认的淘汰策略是删除最早添加的元素,只不过触发条件为永远返回的fasle
        我们需要重写removeEldestEntry方法,当超过指定数量时,返回true即可。
        
 * LinkedHashMap实现删除最旧未被访问数据 
        
        LinkedHashMap也为我们提供了删除最久未被访问的策略,默认是关闭的,我们通过有参构造函数开启
        LinkedHashMap map = new LinkedHashMap(16, 0.75f, true);
 
### 布隆该过滤器
 
 * 什么是布隆过滤器
        
        布隆过滤器指的是在一定误差率的前提下用较小的空间判断某一元素是否存在。
        当返回true时,指定的元素可能并不存在,但是当返回false时,指定的元素一定不存在。
        
 * 布隆过滤器的原理
        
        布隆过滤器底层通过计算机中最小的单位位(Bit)来实现,使得其可以用较小的空间存储较多的数据。
        类似hashmap,通过将元素进行hash运算确定元素的位置,不同的是,布隆过滤器通过多个hash函数进行定位.
        只有一个元素的所有hash定位的值都为1时,该值才可能存在,有一个不为1,则该值一定不存在
        hash函数的数量和位图的长度决定了误差率的大小。
 
 * 应用场景
        
        新闻客户端推送新的内容。
        邮箱系统垃圾短信的过滤。
        秒杀活动接口的防刷。
        
 * redis的实现
        
        Redis中布隆过滤器的底层实现是bitmap,redis提供了java客户端工具类(单节点布隆过滤器)
        
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.14.104:6379");
        config.useSingleServer().setPassword("123");
        RedissonClient redisson = Redisson.create(config);
        RBloomFilter<String> bloomFilter = redisson.getBloomFilter("phoneList");
        bloomFilter.tryInit(100000000L,0.03);
        bloomFilter.add("10086");
        System.out.println(bloomFilter.contains("123456"));//false
         
        Google中布隆过滤器实现
        
        BloomFilter<String> bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8),100000,0.01); 
        bloomFilter.put("10086");
        bloomFilter.mightContain("123456")
        
### HyperLogLog(不理解其原理、后续再理解)
        
 * 什么是HyperLogLog
        
        HyperLogLog是Redis对基数算法的实现。
        bitmapmap虽然也能用于判断元素是否出现,但是不适合大数据场景,因此出现了HyperLogLog
        
  * 应用场景
        
        50亿个电话号码,现有10万个电话号码,如何判断这10万个是否已经存在在50亿个之中。
        
### Redis发布订阅
    
  * list实现(一对一)
        
        通过List集合来实现,比如左进右出和右进左出,默认是不支持消费者等待的
        我们可以使用blpop来实现等待
        
  * 发布订阅模式(一对多)
  
        publish topic  context   发布消息
        subscribe topic          订阅消息
        
  * redis发布订阅的缺点
        
        redis发布订阅的数据缓存空间是定的,数据量过大会造成数据丢失
        当消费者断线重连后会造成数据丢失,因为redis没有提供持久化机制
    
### Redis事务

 * 什么是事务
        
        事务是一个单独的操作,事务中的命令都会被序列化后按顺序的执行。不会被其他的命令打断。
        本质是通过multi、exec、watch等一组命令的集合
 
 * Redis事务符合ACID吗？
        
        Redis并不遵守ACID标准,Redis中的事务指的是一组命令执行期间不可以执行其他命令
        事务中的各个命令执行成功失败互不影响
 
 * Lua脚本
        
        Lua脚本也是事务的一种实现,将脚本中的多个命令序列化为一个发送给Redis服务器。     
  
### Redis集群模式(服务端路由查询)    

 * 什么是集群模式
        
        哨兵模式下,master节点只有一个,所有的写操作都会在该节点上操作。
        集群模式采用了服务端Sharding技术,通过分区的思想将写操作打散到几个不同
        的写节点上。提高了写节点的能力。
        redis集群只能选择0号数据库。
 
 * 集群模式原理
        
        通过hash的方式将数据分片,每个写节点负责一部分hash值,默认分配了16384 个槽位。
        可以动态的添加节点(前提是存在未被使用的hash槽),删除节点是必须保证该节点的所有hash槽位
        没有数据。
        
        集群架构下的每个redis节点需要开发两个端口,6379和16379。
        16379用于集群中各个节点的信息通讯。            
        
### Redis Sharding和Redis Cluster的区别

 * 区别
        Redis Sharding是在客户端进行hash找到具体redis实例
        Redis Cluster是在服务端进行hash通过路由找到具体实例
        
### 生产环境中的redis如何赋值
 
 * 部署
        
        生产环境下主从机器需要部署在不同的服务器上, 以十台机器为例, 五台部署主机，舞台部署从机,建设每台主机
        qps是5w/s,五台就是25w/s。
        
        每个redis的内存设置为10G最好。
        
### 热点数据和冷数据
   
  * 什么样的数据需要缓存
        
        适合缓存哪些读多的数据、新闻消息等
        
        写多的数据有时也需要缓存,否则数据库压力太大,比如微博排行班的点赞数
        每个新闻都是一个String类型的键值对，用来计数
        计数完、成后添加值zset中
        
        
### Redis分布式锁的使用

 * 集群部署时,定时任务需要控制只有一个服务执行
 * 集群部署时,每次访问都需要一个新的token时,需要保证方法执行完再释放锁

### Redis发布订阅的使用
 
 * 集群部署时,初始化方法只需要由一台服务执行一次并通知其他服务
