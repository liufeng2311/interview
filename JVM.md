###JVM内存模型
 
 * java内存模型
 
        java内存模型定义了程序对各个变量的访问规则,这里的变量指的是实例字段、静态字段和构成数组对象的元素,
        并不包括局部变量和方法参数,因为局部变量个方法参数属于栈帧操作,是线程私有的
        java中的每个线程都有自己的工作内存,工作内存中保存了主存的变量的拷贝,线程只能和工作内存打交道,这就导致
        工作内存中有些数据可能和主存存在差异,产生缓存一致性问题   
        
 * 缓存一致性的解决办法
        
        锁机制和volatile关键字(详情参考jdk.md)     
        
###JAVA内存模型

  * JVM内存模型
         
         JVM的内存模型指的是JVM的运行时数据区, 细分为如下几部分
         方法区、本地虚拟机栈、虚拟机栈、堆、程序计数器
 
  * 方法区
         
         主要保存类的元信息, 可以理解的是class对象
         方法区只是概念,1.8之前的实现是永久代, 1.8之后的实现是元空间
         
  * 本地方法栈
         
         JNI,native()方法有关的调用 
             
  * 虚拟机栈
         
         java方法执行区域,每一个线程都会存在一个虚拟机栈,虚拟机栈中存放着栈帧,每个方法调用都会生成一个栈帧
         栈帧包括：
         局部变量表： 保存着方法用到的变量
         操作数栈：操作的数据,JVM先将数据入栈,在出栈赋给局部变量表
         动态链接：该方法在方法区的内存地址,用于获取静态变量
         返回地址：存储该方法执行完成后下一步指令的位置
         
  * 堆  
         
         存储具体的对象,细分为新生代和老年代
         新生代又分为Eden区、From区和To区, 比例为8:1:1 
         
  * 程序计数器
         
         字节码指令,用来记录程序下一个指令的位置 

###类加载机制

   * 类从被加载到虚拟机内存到清理出虚拟机内存的生命周期
      
          加载--> 验证--> 准备--> 解析--> 初始化--> 使用--> 卸载
  
   * 加载 
         
         通过一个类的全限定名获取类的二进制字节流
         在方法区生成该类的运行时数据结构(该结构可以获取类的信息)
         生成该数据结构的Class对象作为该类数据结构的入口(用于反射) 
         
         加载的时机为：
         调用类的静态字段或方法
         主线程所在的类
         初始化一个对象(通过反射或者new对象)
   * 验证 
          
          验证类的二进制字节流是否符合虚拟机规范
   * 准备 
          
          为类的静态变量分配初始值,这里只是分配初始值,static int = 12; 这里的赋值为0
          被final修饰的直接赋值(因为该值不会被改变了)
          静态变量和类一样位于方法区
   * 解析 
          
          将常量池中的符号引用改为直接引用。
          符号引用也就是间接引用,指向的是方法区里该类结构
          直接引用指向的是堆区实例的内存地址
   * 初始化 
          
          之执行我们类中的代码,将准备阶段的初始化赋值为代码中定义的值
   * 使用 
          
          使用
   * 卸载 
          
          卸载

###双亲委派机制

 * 类加载器
        
        类加载的定义：指的是通过一个类的全限定名来获取描述此类的二进制字节流的动作。
        同一个类只有被相同的类加载器加载才能说两个类相等
        每个类加载器都有自己固定扫描的路径,加载类时是通过类的全限定名,如果在其加载路径下没有找到该类,则认为该类加载器无法加载该类
        不同的类加载器加载的类在JVM中是分开的,每个类加载器都有自己的隔离空间
        
 * 默认的三个类加载器
        
        BootstrapClassLoader: 启动类加载器,是虚拟机的一部分,通过C++程序编写, 加载JAVA_HOME/lib包下的指定jar
        
        ExtClassLoader：扩展类加载器,虚拟机外部的,通过JAVA编写, 加载JAVA_HOME/lib/ext包下的指定jar
        
        AppClassLoader: 应用程序类加载器,虚拟机外部的,通过JAVA编写, 加载classpath下的文件
 
               
 * 双亲委派模型
        
        除了启动类加载器以外,任何的类加载器都需要有自己的父类加载器,并不是继承父类而是保存了父类加载器信息(组合模式)
        当一个类加载器加载类时,首先会通过自己的父类去加载,如果直到启动类加载器都无法加载时,他才会去自己加载该类
        
        JAVA中的实现逻辑, 查找当前类加载器是否加载过了,没有的话判父加载器是否为null,如果不为null,重复之前步骤
        当父类加载器为null时,就通过启动类加载器加载,依旧无法加载,抛出一个异常后再由当前类加载器加载
        
 * 打破双亲委派模型
        
        父类加载的需要加载的类位于子类中, 需要向下查找,就这违背了双亲委派模型。JVM团队引入了线程上下文加载器来实现向下查找
        如果没有指定的话就为应用类加载器，并不是说违背了双亲委派就不好,而是一种创新
        SPI机制的实现
        热部署机制的实现
        
 * loadClass()和findClass()的区别
        
        loadClass()表示的父类去加载
        findClass()表示的自己去加载
        
        这也是双亲委派的一个保证,先调用loadClass()通过父类去加载,父类加载不到的话在通过findClass()自己去加载

###OOM如何排查

 * OOM分类
    
        JVM设置的内存过小(内存溢出)
        应用的内存无法释放(内存泄漏)

 * OOM常见情况
        
        堆溢出：内存泄漏或堆大小太小造成
        方法区溢出：Class文件太多或者动态生成的Class太多    
        栈溢出：死循环或者深度递归造成   

###JVM常用参数

 * 如何设置新上线的java服务的内存大小
        
        JVM大小: Full GC后老年代大小的三到四倍
        方法区大小：PermSize和MaxPermSize为Full GC后老年代的1.2到1.5倍
        年轻代：Full GC后老年代的1到1.5倍
        老年代：Full GC后老年代的2到3倍
        
        堆大小：堆大小 = 年轻代 + 年老代(xmx = xmn + 老年代)
        
  
 * 设置JVM最大内存和最小内存(通常我们将JVM最大内存和最小内存设置为相同的值防止内存波动)
        
        -Xmx512M       设置JVM最大内存
        -Xms512M       设置JVM最小内存
        -Xmn           年轻代大小
        -Xss           每个线程最大大小
        

 * 错误诊断
        
        -verbose:class  输出jvm载入类的相关信息，当jvm报告说找不到类或者类冲突时可此进行诊断。
        -verbose:gc     输出每次GC的相关情况。
        -verbose:jni    输出native方法调用的相关情况，一般用于诊断jni调用错误信息。                

    
 * 常用设置
        
        -XX:+PrintGCDetails           +表示启动   -表示禁用
        -XX:PretenureSizeThreshold    设置超过该值大小的直接进入老年代
        -XX:NewRatio=4                设置年轻代和老年代的比例
        -XX:SurvivorRatio=4           设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
        
        
        -XX:+UseParallelGC -XX:ParallelGCThreads=20    年轻代使用ParallelGC,并行数为20
        -XX:+UseParallelOldGC          配置老年代GC      
        -XX:MaxGCPauseMillis=100       设置每次年轻代垃圾回收的最长时间
        -XX:+UseAdaptiveSizePolicy     设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例
        -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./oom.hprof
        
        -XX:MaxMetaspaceSize=512m      配置元空间大小
        
 * OOM排查
        
        dmesg |grep -E ‘kill|oom|out of memory’  对Heap size和垃圾回收状况的监控。
        jmap -histo:live pid    查看存活的大对象
        jmap -dump:format=b,file=文件名 [pid] 
        