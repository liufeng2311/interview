##mysql面试(线上问题排查在后面)

###一、数据库设计的三大范式
    
 * 第一范式
        
        表中的每一项数据都是不可分割的(每个字段都只能存储一个独立的信息)
 * 第二范式      
        
        表中所有的非主键列都只能和主键确定唯一关系,而不是联合主键(一对多不能存储在同一张表中)
 * 第三范式       
        
        表中所有的非主键列都只能和主键确定唯一关系,非主键列之间不能存在关联(防止数据冗余,比如存了用户ID就不能存用户姓名)
 * 遵守规则
     
        第一范式和第二范式必须遵守,第三范式在某些场景下可以不遵守(适当的冗余可以减少表关联查找)

###二、 事务的四大特性(ACID)
    
 * 原子性
        
        事务中的操作要么全部成功,要么全部失败。
       
 * 一致性(不同会话中)
        
        事务执行前、执行中、执行完毕，其他会话同一时间观察到的数据总是一致的。
        比如A会话在执行事务时, B会话看到的是100, 那么C会话此时观察到的也一定是100。
        
 * 隔离性(不同会话中)  
   
        不同事务中数据的可见性
        并不意味着各个事务见完全不可见(四种隔离级别)
        
 * 持久性
    
        事务一旦提交就会被永久保存。数据会被永久保存到硬盘。
        
###三、不同会话间数据可见性问题
      
 * 脏读
        
        一个事务可以读取其他事务中未提交的数据。
        该数据可能因为其他事务回滚而变成无效数据。
        
 * 不可重复读(针对的是所有的查询语句)
        
        一个事务中相同的查询语句在多次执行中返回不同的结果。
        查询单条数据记录时返回的不一致
        查询结果集时返回的结果集不一致。
 
 * 幻读
        
        在可重复读的模式下, 事务察觉不到其他事务对数据的改变。对于那些被其他事务改变的数据,导致该事务感觉自己读到的数据不对
        
        事务A操作如下：
        1、打开事务
        2、查询号码为X的记录，不存在
        3、插入号码为X的数据，插入报错(提示该号码已存在)
        4、查询号码为X的记录，发现还是不存在(由于是可重复读, 事务读取不到最新的数据, 所以在看看来X还是不存在的)
        
        事物B操作：在事务A第2步操作时插入了一条X的记录，所以会导致A中第3步插入报错（违反了唯一约束）
        
        上面操作对A来说就像发生了幻觉一样，明明查询X（A中第二步、第四步）不存在，但却无法插入成功
        
        
        
        
        
    
###四、隔离级别(解释存在问题)
 
 * 读未提交(Read uncommitted)
        
        可以读取到其他事务还未提交的数据, 多次读取结果不一样。
        出现了脏读、不可重复读
        
 * 读已提交(Read committed)
 
        只能读取到其他事务已经提交的数据, 多次读取结果不一样
        出现了不可重复读
        
 * 可重复读(Repeatable read)
 
        只能读取到其他事务已经提交的数据, 多次读取结果一样
        出现了幻读
        
 * 串行读(serializable)
    
        事务顺序执行, 不会出现问题
        
###五、MYSQL和ORACLE默认的隔离级别分别是什么

 * MYSQL
 
        采用的隔离级别是可重复读
        
 * ORACLE  
   
        采用的隔离级别是读已提交

###六、可重复读是如何实现的(MVCC机制)(https://www.jianshu.com/p/8845ddca3b23)(不做具体了解)

 * MVCC机制(只针对读已提交和可重复读)
    
        MYSQL采用多版本并发控制来解决该问题,开启事务时会保存一个快照
        数据的读取都从快照版本中进行,更新数据都在最新版本中进行
 
 * 当前读和快照读
        
        当前读表示读取的是最新版的数据,是需要加锁的(共享锁和排他锁)
        快照读读取的不是最新版数据,不需要加锁,读到的数据可能不是最新的,普通的select就是使用的快照读
        
* MVCC原理(基于行锁)

    *   RR和RC的区别
        
        RR只有第一次读生成快照,所以多次查询结果一致,RC每次读都会生成快照,所以查询结果不一致
###七、MYISAM和INNODB
    
 * MYISAM
        1. 不存在事务
        2. 不支持外键
        3. 采用非聚簇索引,索引保存的是数据的地址
        4. 通过一个字段保存了表的具体行数
        5. 只支持表锁
        6. 当表的作用只是为了查询, 采用MYISAM
 * INNODB
        
        1. 存在事务。每一条sql语句都默认为封装为一个事务,自动提交。
        2. 支持外键
        3. 采用聚簇索引
        4. 不保存行数, 因为事务的原因, 不同的事务中行数时不一致的,需要事务自己去统计
        5. 支持表锁和行锁, 行数是在索引上实现的。意味着没有命中索引的语句会使用表锁。
        
###八、B+Tree和Hash的区别
    
 * B+Tree 
        
        支持排序和范围查找
 * Hash
        
        等值查找效率更高,但不支持排序和范围查找
        
###九、索引类型

 * 聚簇索引
        
        索引的节点保存的是具体的数据
 * 非聚簇索引
        
        索引的节点保存的不是具体的数据,只是指向具体数据的指针
 * 联合索引(组合索引)
 
        多个字段共同作为索引,遵循最左匹配原则
 * 覆盖索引
 
        查询的数据正好位于索引中
 * 唯一索引
 
        数据唯一可以为空
 * 主键索引
 
        数据唯一且不能为空
        
###十、索引的优缺点

 * 优点
        
        查询数据库
 * 缺点
        
        更新数据慢, 占用空间
        
###十一、MYSQL为什么使用B+Tree作为索引
    
 * 原因
    
        主要和磁盘的IO次数有关, B+Tree树的层数更少,可以更快的定位和加载到数据
        MYSQL采用页的数据结构和磁盘每次能读取的保存一致,查询出数据的时候还能预加载数据
    
###十二、SQL优化

 * 使用索引
        
        常用的查询最好都可以通过索引查找,并不意味这索引越多越好, 最好创建联合索引,避免多个独立索引
        
 * 避免索引失效  
        
        创建索引时需要考虑到分组和排序的字段,通过最左原则创建联合索引
        避免select *造成覆盖索引失效,无用的字段会影响查询效率和占用内存
        字段最好设置默认值,避免NULL值的出现,因为NULL值可能造成影响索引失效
        过滤条件不要使用模糊查询, 即使使用左侧也必须是确定的
        避免使用not in和 !=
        索引字段的数据类型必须一致,否则索引会失效
        当in和or中的字段为索引时,使用union all,mysql会自动帮我们优化
        过滤语句左侧不可以出现表达式,右侧可以
        当一个字段的取值范围固定且存在大量重复,使用索引的意义不大
        索引的个数控制在最多六个,不然造成更新效率低且占据空间
        尽量使用数值类型,而不是字符串

###十三、MYSQL中存在哪些锁(锁都是针对不同的事务,类似多线程)(暂放)
 * 概括
        
        MYSIAM只存在表锁,不会发生死锁问题
        InnoDB存在表锁和行锁(细分为读锁和写锁),行锁就意味着会出现死锁
        行锁是通过索引实现的,不经过索引的话就意味着获取的是表锁
        在事务未执行完成时是不会释放锁的
 * 读锁
        
        select * from person_info where id = 1 lock in share mode;
 * 写锁
        
        select * from person_info where id = 1 for update;
 * 行锁
        
        对某一行数据加锁, 该锁位于索引处, 行锁分为读锁和写锁
 * 表锁   
        
        对整张表加锁
        
 * 悲观锁
        
        悲观锁指的就是行锁

 * 乐观锁
        
        通过一个version字段进行控制
        
 * 间隙锁(针对范围查找)
        
        为了解决查询当前版本的幻读问题,InnoDB会对范围内的所有不存在数据加锁
        例子：
        ID类型为自增,当前最大ID为10, 当前事务查询ID>9的数据(获取大于9的所有不存在数据加间隙锁), 此时其他事务新增都会阻塞
        
        
        
###十四、死锁如何查看和解决

 * 死锁发生的条件
         
        MYSIAM中只有表锁,是不会发生死锁的
        INNODB中存在行锁,只有行锁才会发生死锁

 * MYSQL死锁的解决
        
        MYSQL内部存在死锁处理机制, 死锁50秒就会触发机制,我们可以设置触发时间并记录日志
        查看死锁处理机制触发时间 ：show variables like '%innodb_lock_wait_timeout%';        
        设置死锁日志到mysql错误日志：show variables like '%innodb_print_all_deadlocks%';
        
 * 开发中避免死锁
        
        程序中不同方法访问资源的顺序是一致的
        一个事务中不要存在太多的操作
###十五、慢查询如何查询
    
    
###十六、事务的操作与设置

 * 事务类型
        
        隐式事务：事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由mysql内部自动控制的。
        显式事务：手动开始事务、提交事务、回滚事务

 * 查看事务类型
 
        show variables like 'autocommit';
        
     |Variable_name|Value|Desc|
     |:---:|:---:|:---:|
     |autocommit|ON|开启自动提交|
     |autocommit|OFF|未开启自动提交|
        
 * 设置提交类型
        
        set autocommit=0;  //关闭自动提交
        set autocommit=1;  //开启自动提交
 
 * 操作事务
        
        start transaction;  //开启事务(自动提交处于开启状态的时候需要设置,当状态为关闭时不需要设置)
        commit; 提交事务(提交当前会话里的所有未提交操作)
        rollback; 全部回滚事务(回滚当前会话里的所有未提交操作)
        savepoint part1;//设置一个保存点
        rollback to part1; /将savepint = part1的语句到当前语句之间所有的操作回滚
        
###十六、数据库部署、主从复制和集群



###十六、Spring中事务的传播特性
 
 * 事务的传播特性(调用方可以没有事务,被调用方必须存在事务,传播行为总是针对被调用方来说的)
 
        1.Propagation.REQUIRED(需要事务,被调用方总会执行在事务中)
            如果调用方存在事务,则使用调用方的事务
            如果调用方不存在事务,则为被调用方创建一个新的事务执
        2.Propagation.SUPPORTS(支持事务,被调用方是否执行事务取决于调用方是否有事务)
            如果调用方存在事务,则使用调用方的事务
            如果调用方不存在事务,则被调用方采用无事务的方式执行
        3.Propagation.MANDATORY(调用方必须存在事务,被调用方必须在事务中且被调用方不会新建事务,即调用方必须存在事务)
            如果调用方存在事务,则使用调用方的事务
            如果调用方不存在事务,则抛出异常
        4.Propagation.REQUIRES_NEW(创建新的事务,被调用方总是在新的事务中执行且被调用方的事务不依赖于调用方)
            如果调用方存在事务,为被调用方创建一个新的事务执,相互独立
            如果调用方不存在事务,为被调用方创建一个新的事务执,相互独立
        5.Propagation.NOT_SUPPORTED(不支持事务,被调用方将事务挂起)
            如果调用方存在事务,被调用方将事务挂起,采用无事务方法执行,执行完后恢复调用方事务
            如果调用方不存在事务,被调用方采用无事务的方式执行
        6.Propagation.NEVER(调用方必须不存在事务)
            如果调用方存在事务,抛出异常
            如果调用方不存在事务,被调用方采用无事务的方式执行
        7.Propagation.NESTED(创建新的事务,被调用方总是在新的事务中执行且被调用方的事务依赖于调用方)
            调用方存在事务,子方法被NESTED修饰且发生异常,回滚本次子方法的测试,调用方必须捕获异常,防止异常上抛引起全部回滚
        注意点:
        1.REQUIRES_NEW和NESTED的区别
             REQUIRES_NEW侧重于调用方方法回滚不会影响被调用方法
             NESTED侧重于调用方方法回滚,被调用方法必须全部回滚
        2.同类调用会造成被调用方法注解失效
        
        
###线上问题排查

 * 查看当前连接的进程数(链接数)
 
    show processlist;
    
    链接只要存在就会显示一条数据,当没有任务或者阻塞时,其状态为Sleep
 
 * 查看正在执行的事务
    
    SELECT t.* FROM information_schema.INNODB_TRX t
    
    所有正在执行的事务信息都会记录在该表中
    
 * 查看当前出现的锁(只有当出现锁竞争时才会记录在INNODB_LOCKS表中)
    
    SELECT t.* FROM information_schema.INNODB_LOCKS t
 
 * 查看锁的等待关系
        
        SELECT t.* FROM information_schema.INNODB_LOCK_WAITS t
 
 * kill线程(发生死锁时关闭某线程)
        
        kill id;
        
        id为INNODB_TRX中trx_mysql_thread_id字段的值。
 
 * 查看当前缓存总打开的表
 
        show open tables where in_use > 0 ;
        
        当该结果返回为空时表示没有表被使用,不会发生死锁。
        
 * 查看表锁和行锁的竞争情况
        
        show status like 'table%';
        show status like 'InnoDB_row_lock%';
 
 * 设置死锁退出时间
        
        set global innodb_lock_wait_timeout = 10;
 
 * 查看最新的死锁日志
        
        show engine innodb status;