## JAVA面试

###一、JAVA内存模型、volatile、缓存一致性

 * 缓存一致性问题
        
        高速缓存的引入解决了处理器与内存之前的矛盾,但是如何保证各个缓存中的数据的正确性就是所谓的缓存一致性问题
        因为各个高速缓存都只和主存打交道,缓存间的数据是不通信的,就可能导致各个高速缓存和主存数据存在不一致问题
        
 * JAVA内存模型
        
        java内存模型定义了程序对各个变量的访问规则,这里的变量指的是实例字段、静态字段和构成数组对象的元素,
        并不包括局部变量和方法参数,因为局部变量个方法参数属于栈帧操作,是线程私有的
        java中的每个线程都有自己的工作内存,工作内存中保存了主存的变量的拷贝,线程只能和工作内存打交道,这就导致
        工作内存中有些数据可能和主存存在差异,产生缓存一致性问题
        
 * volatile关键字
        
        volatile定义了两层语义：
        可见性：线程使用 volatile修饰的变量时,需要从主存中再次加载该变量,而不是直接使用工作内存中的
        防止重排序：普通的变量只能保证方法执行过程中所有依赖结果的地方都是正确的结果,而不能保证变量的赋值过程和代码一样
        volitile提供了内存屏障保证后面的语句不会重排序到该屏障前面
        
        使用双重检测机制创建单利模式的,必须使用volatile修饰,原因如下
        Object obj = new Object();
        上述代码其实包含三步:  
        1. Object = allocate();    //分配对象的内存空间
        2. initInstance(Object);   //初始化对象
        3. obj = Object;           //将内存分配给引用
        
        上述步骤编译期可能将顺序优化为1、3、2,因为第一步已经取到Object,直接赋值给obj在编译期看来是正确的,所以我们需要使用volatile修饰
        
 * volatile修饰引用类型和数组
        
        当volatile修饰引用类型和数组时,只能保证引用可见性,并不能保证属性的可见性。
        当我们需要获取引用类型或者数组的具体值时,通过Unsafe类中getObjectVolatile(Object o, long offset)从主存中拿到最新值
        
 * volatile的底层实现(内存屏障)
        
        编译器在生成字节码时, 会在每个使用volatile变量的位置都添加上内存屏障, 具体如下：
        
        在每个volatile写操作的前面插入一个StoreStore屏障。
        在每个volatile写操作的后面插入一个StoreLoad屏障。
        在每个volatile读操作的前面插入一个LoadLoad屏障。
        在每个volatile读操作的后面插入一个LoadStore屏障。
        
        这些内存屏障保证了变量在使用时必须从主存中进行加载,使用后必须写入主存,类似原子性操作
        同时指定了只有两个屏障间的代码可以重排序,不能跨屏障重排序
###二、synchronized和lock

 * synchronized
    
        synchronized是java内置关键字,属于JVM层面的,锁住的是实例对象, 锁的信息存储在对象头部, 可以用在方法或者代码块上, 锁的释放由JVM管控
        synchronized是可重入的互斥锁,采用非公平的方式实现且不支持中断
        jdk1.6对锁进行了优化,也就是所谓的锁膨胀。无锁-->偏向锁-->轻量级锁-->重量级锁(锁升级的过程类似先自旋在加锁)
 * lock  
    
        lock是基于AQS实现的,属于JAVA代码实现的,所在信息存储在AQS的state变量中, 作用在方法里, 锁的释放由开发者管控
        lock是可重入的互斥锁,引入了公平锁和响应中断的实现
        lock锁的出现主要是为了弥补jdk1.6前synchronized锁的缺陷,同时提供了更丰富的API,包括尝试获取锁、尝试指定时间获取锁、支持可中断等
        AQS下的condition机制细化了线程的等待与唤醒机制,使得控制更精准
###三、AQS

 * 什么是AQS
 
        AQS全称AbstractQueuedSynchronizer,表示抽象的同步器队列。采用模板模式去实现具体的功能。
        AQS内部维护了三个变量来控制多线程对共享资源的访问(锁状态信息字段state、锁的持有者exclusiveOwnerThread、FIFO队列)          

 * AQS如何实现可重入锁和不可重入锁
        
        可重入锁指当前线程为锁的持有者, 可以再次获取锁,具体实现是将state+1
        不可重入锁指state被线程持有时,任何线程无法再次获取锁
        
 * AQS如何实现公平锁和非公平锁
        
        公平锁指获取锁的线程必须满足队列为空或位于队列的头部才可以去获取锁,否则加入队列尾部
        非公平锁指线程每次获取锁时不必判断队列是否有其他的元素,只要锁处于空闲状态就去获取

 * Condition是如何实现的
        
        Condition自身内部含有一个队列,用来存储该条件下等待的线程
        当调用await()方法时,记录当前线程锁的信息并释放锁,将当前线程放入Condition对象的队列中阻塞,等待唤醒
        当调用signal()方法时,唤醒队列中的元素并将该节点放FIFO队列中等待获取锁
        
 * AQS中的节点是怎么设计的
 
        节点的线程：保存当代获取锁的线程信息
        节点的前继：线程阻塞时需要告知前继线程你需要唤醒我
        节点的后继：线程判断后继线程是否需要唤醒
        节点的状态：当前线程的任务是否意味取消等
        节点的类型：共享锁模式还是排它锁模式
        
 
 * CountDownLatch和CyclicBarrier
        
        CountDownLatch表示的是主线程必须等待其他线程都完成任务才可以继续执行
        CyclicBarrier表示到达指定的线程数后这些线程才可以执行
        
###四、ConcurrentHashMap如何保证读写安全的

* 写安全
        
        通过synchronized对数组中的节点进行加锁,实现分段锁,可以提高并发量。
        当tab[i]为空时,通过CAS进行赋值。
        
* 读安全  
        
        tab属性使用volatile修饰,保证引用在各个线程中可见,线程扩容后新数组可以立即可见
        tab[i]的设置和获取通过getObjectVolatile(Object o, long offset)和putObjectVolatile(Object o, long offset, Object x),保证各个线程对tab[i]的可见性
        Node节点中的next属性和val属性使用volatile修饰,保证获取当前节点和下一个节点都为最新值
        
        TreeNode里面的left和right没有用volatile修饰,如何保证安全的
            
* 扩容
        
        当数据超过阈值的发起扩容,其他线程发现正在扩容时协助扩容
        每个线程通过循环领取扩容任务直至没有扩容任务退出本次扩容任务(数组从右到左领取扩容任务)
        整体扩容完后再次统计是否需要发起新一轮的扩容       
###五、线程池
* 原理

        添加至线程池中的任务都不会创建线程, 线程池中的线程都是由参数中的线程工厂去创建 
        
* 创建线程池的方式
      
        Executors.newSingleThreadExecutor();     创建只有一个线程的线程池(无界队列)
        Executors.newScheduledThreadPool(2);     创建定时任务的线程池(无界线程数)
        Executors.newFixedThreadPool(2);         创建固定大小的线程池(无界队列)
        Executors.newCachedThreadPool();         创建一个同步线程池(无界线程数)
* 参数   
        
        corePoolSize    核心线程数(核心线程数空闲时不会被回收,但可以通过参数allowCoreThreadTimeOut设置为可回收)
        maximumPoolSize 最大线程数
        keepAliveTime   非核心线程数存活时间
        unit            keepAliveTime所设置时间的单位
        workQueue       阻塞队列,存放任务体
        threadFactory   线程工厂,线程池中的线程都是由该工厂创建的
        handler         拒绝策略,当任务无法执行时采用的策略             
* 拒绝策略
        
        CallerRunsPolicy         由调用者线程执行        
        AbortPolicy              抛出异常(默认拒绝策略)        
        DiscardPolicy            不做任何处理       
        DiscardOldestPolicy      丢弃最早的任务     
* 阻塞队列
        
        LinkedBlockingQueue      列表无界队列, 引发OOM, 内部由
        SynchronousQueue         同步队列, 引发OOM和CPU100%
        ArrayBlockingQueue       数组有界队列, 推荐使用
        DelayedWorkQueue         延迟队列, 引发OOM和CPU100%
        
* 返回值任务的执行       
        
        封装为Call接口且实现Future接口,实现类通过保存任务的执行状态和保存获取该任务的结果的线程链来实现,依旧采用的阻塞和唤醒
        
* 如何实现一个定时任务线程池
        
        定时任务使用的是延迟队列
###六、JVM内存模型

 * JVM内存模型
        
        JVM的内存模型指的是JVM的运行时数据区, 细分为如下几部分
        方法区、本地虚拟机栈、虚拟机栈、堆、程序计数器

 * 方法区
        
        主要保存类的元信息, 可以理解的是class对象
        方法区只是概念,1.8之前的实现是永久代, 1.8之后的实现是元空间
 * 本地方法栈
        
        JNI,native()方法有关的调用     
 * 虚拟机栈
        
        java方法执行区域,每一个线程都会存在一个虚拟机栈,虚拟机栈中存放着栈帧,每个方法调用都会生成一个栈帧
        栈帧包括：
        局部变量表： 保存着方法用到的变量
        操作数栈：操作的数据,JVM先将数据入栈,在出栈赋给局部变量表
        动态链接：该方法在方法区的内存地址,用于获取静态变量
        返回地址：存储该方法执行完成后下一步指令的位置
 * 堆  
        
        存储具体的对象,细分为新生代和老年代
        新生代又分为Eden区、From区和To区, 比例为8:1:1 
 * 程序计数器
        
        字节码指令,用来记录程序下一个指令的位置 
            
###七、SpringBean的加载过程
 * Bean的生命周期(以注解方式为例)
        
        1. 根据@ComponentScan属性来扫描需要被Spring管理的Bean,为每一个类生成一个BeanDefinition对象来存储类的信息
        2. 根据BeanDefinition实例化Bean对象并进行属性填充
        3. 执行Spring相关回调函数,设置BeanName、BeanFactory、ApplicationContext、BeanClassLoader
        4. 执行Bean的后置处理器中的初始化前方法(对所有对象生效)
        5. 执行被@PostConstruct修饰的方法
        6. 执行InitializingBean类的afterPropertiesSet()方法
        7. 执行Bean的后置处理器中的初始化后方法(对所有对象生效)(AOP就是在该步实现的)
        8. 经过前七步我们的Bean已经创建完成
        9. 我们在容器关闭时(主动调用close()方法)会触发Bean的关闭方法,先调用preDestroy()方法,执行完毕后调用DisposableBean接口的方法,该方法也是一个验证方法
       
 * 构造方法的选择(以注解方式为例)
        
        1. 如果只有一个无参构造方法的话就使用无参构造方法
        2. 如果只有一个有参构造方法的话就使用有参构造方法
        3. 多个构造方法如果指定了构造方法就使用指定的构造方法
        4. 多个构造方法如果没有指定就使用无参构造方法
        
 * AOP的本质
        
        AOP是在BeanPostProcessor中实现的 
        通过ProxyFactory代理工厂、Advice(切面)、target(原始对象)来生成代理类
        
###七、Spring是如何解决循环依赖的
 * Spring不能解决哪种类型的循环依赖
        
        只能解决存在单例bean的循环依赖, 原型模式和构造器的循环依赖是无法解决的
       
 * Spring解决循环依赖的思想
        
        1. 创建对象时将对象的信息存放到三级缓存中(如果发生循环依赖该缓存将会被使用到)
            通过lambda表达式保存到第三级缓存,包括了原始对象、对象名字、对象定义
            创建代理对象的时候是需要原始对象的
        2. 进行属性赋值时如果发现依赖的对象正在创建中,从二级缓存中取出该对象的代理对象进行赋值
           如果二级缓存中没有则根据三级缓存信息生成一个存入二级缓存(同时删除三级缓存信息)
        3. 赋值完成后判断当前对象是否进行过AOP
            没有的话则进行AOP并将AOP的对象放入一级缓存(删除三级缓存)
            进行过AOP表示已生成代理对象,从二级缓存中取出代理对象放入一级缓存
        4. 创建完毕
 
 * Spring使用三级缓存来解决循环依赖
        
        一级缓存为：singletonObjects        保存已经创建好的单例对象
        二级缓存为：earlySingletonObjects   保存的是未完全创建好的对象,通常是循环依赖的AOP对象
        三级缓存为：singletonFactories      Bean工厂,保存的是lambda表达式,包含beanName,bean的原始对象和bean定义,当发生循环依赖时生成代理对象
        AOP缓存：earlyProxyReferences      保存了提前AOP的beanName
        
                
 * 执行流程(lambda表达式包含了bean的原始对象、beanName、beanDefine)        
        
        1. 创建原始对象,通过lambda表达式保存到第三级缓存(如果没有循环依赖, 该lambda表达式是不执行的)
        2. 属性赋值(如果在第三级缓存中找到该对象则表示出现循环依赖,创建AOP对象放入二级缓存并删除三级缓存信息)
        3. 属性赋值完成后进行AOP(进行过AOP的此步不再进行AOP,通过一个缓存保存了AOP过的对象)
        4. 若对象不是提前进行AOP的,直接加入一级缓存,提前进行AOP的存二级缓存中取出加入一级缓存
        
###八、SpringMVC流程
 * 执行流程
        
        1.WEB容器接收到请求后调用DispatherServlet实现类的service方法
        2.通过HandleMapping组件找到对应的处理器, 封装所有的拦截器返回一个执行器链
        3.通过HandlerAdapter确定该处理器的类型并执行处理器,返回ModelAndView
        4.通过视图解析器解析器找到需要的视图进行相关处理
        5.通过model渲染视图并返回给前端
###九、TCP的三次握手和四次挥手
 * TCP报文
        
        TCP是一种可靠性连接,报文结构中存在如下重要字段
        
        客户端IP和端口、服务器IP和端口
        当前报文序列号(随机的), 确认应答号(接受到报文,将报文序列号+1作为响应)
        报文的性质SYN、ACK、FIN
 * 三次握手(第一二次握手不携带数据)
        
        第一次握手：客户端请求服务器,报文中携带自己的序列号和报文性质SYN, 等待服务器响应
        第二次握手：服务端接受请求后,序列号改成自己的序列号,将报文原序列号+1存在确认应答中,设置状态为ACK
        第三次握手：客户端接受请求后,改成自己的序列号,将报文原序列号+1存在确认应答中,设置状态为ACK
        
       为什么不是两次握手呢？
       第三次握手是因为可能由于网络堵塞,客户端发送了多次请求,存在旧请求比新请求先到的情况,当旧请求返回客户端后,客户端可以
       判断出该请求已过期,通知服务端关闭旧请求连接 
        
        
 * 四次挥手
        
        第一次挥手：客户端发送请求通知服务器我准备关闭了,报文标志FIN
        第二次挥手：服务器接收到后发送ACK给客户端表示接受到
        第三次挥手：服务器发送FIN给客户端表示请求处理完毕
        第四次挥手：客户端接收到后发送ACK给服务器表示接受到,双方都进入关闭状态
        
###十、MVCC机制、间隙锁
 * 读锁和写锁
        
        学习MVCC机制前我们必须理解MYSQL中的读锁和写锁,MYSQL中的读写锁其实和JAVA中的读写锁类似,MYSQL中的行锁是在聚簇索引中实现的(意味着不走索引只能获取表锁)
        当访问行的数据的读锁被其他事务获取时,此时只能获取他的读锁
        当访问行的数据的写锁被其他事务获取时,此时只能等待,既不能读也不能写
        
        MVCC中的多版本访问指的是访问某一行数据的某个版本, 访问最新版本数据时必须获取该行数据的读锁
        
 * undo log文件
        
        该文件有两个作用: 回滚 + MVCC
        我们需要明确的是多版本访问和本事务回滚是没有任何联系的
        回滚指的是回滚本事务的所有修改操作,本事务必然持有被修改行的写锁,其实其他事务是无法读取到这些行的数据的
        MVCC指的是我访问某行数据之后,该行数据被其他事务修改并提交了,我再次访问时只能访问其他事务未修改前的版本,其他事务获取写锁未提交期间是访问不到该行数据的
 * MVCC
        
        MVCC的多版本是针对行而言的,同一时刻undo log可能同时存在一个数据的多个版本
        根据当前行中的数据以及undo log中的语句就可以得到该行各个版本的数据
        
 * 事务回滚的原理
        
        事务中的每次修改操作都会在undo log中生成相反的sql语句, undo log中生成的语句总能使数据恢复原样
        我们新增语句会生成一条删除语句    
        我们删除语句会生成一条新增语句    
        我们更新语句会生成一条更新语句    
        
* MVCC是如何实现快照读的
        
        一个事务访问某行数据时发现该行数据可能存在多个版本链,如何选择读取哪个版本呢
        事务的ID是按照时间增序的, 每个事务在生成时都会保存当前处于活跃状态的事务ID列表,每条数据修改时都会保存修改它的事务ID, 判断规则如下
        
        1. 数据的事务ID正好是当前事务,说明当前事务含有数据的写锁,该版本可以访问
        2. 数据的事务ID小于活跃事务集合中的最小ID,说明该数据没有被修改过,该版本可以访问
        3. 数据的事务ID大于活跃事务集合中的最大ID,说明该数据被修改过,该版本不可以访问
        4. 数据的事务ID属于活跃事务集合时,说明数据被修改过,该版本不可以访问
        
        概括：
        该事务只能访问小于等于自己版本的数据,如果发现最新版本的事务ID大于自己,通过链表向下查找到小于自己的版本
        
* 版本链的回收机制    
        
        处于活跃状态的最小事务ID大于该版本时,该版本才会被回收

* 幻读
        
        MYSQL中的幻读指的是一个事务可以读取到其他事务新增的数据
        
* RR和RC下的幻读
        
        RR模式下的读是快照读, 读取的是版本数据, 是不存在幻读的, 只有当读操作加锁时才会出现幻读
        RC模式下的读是最新读, 读取的是最新数据, 存在幻读
        
 * RR下的幻读是如何解决的(间隙锁)
        
        出现幻读的原因有两个：
        1. 其他事物新增
        2. 本事务的查询是范围查找
        
        我们通过加锁的方式将范围内的所有数据加锁(包括不存在的数据), 这样就保证了其他事务无锁新增而保证本事务不会出现幻读
        对于那些不存在的数据的锁就是间隙锁
        
 * 间隙锁的应用场景
        
        生产环境数据出错,需要范围批量修改, 此时必须使用间隙锁, 防止修改期间对新增数据也造成修改       
###十一、MYBATIS一二级缓存

 * MYBATIS的一二级缓存指什么
    
        一级缓存指SqlSession级别的缓存(默认开启)
        二级缓存指nameSpace级别的缓存(默认关闭, 配置文件设置cacheEnabled=true开启)
        
###十二、堆外内存、NIO、Netty
 * 堆内内存和对外内存
        
        堆内内存只JVM的内存,推外内存指JVM以外的内存  

 * 用户态和内核态
        
        用户态指的是操作系统上不能直接操作内存、硬盘的应用,
        内核态指可以操作内存、硬盘
        
 * 什么是零拷贝
        
        对于用户态的应用,存储数据需要从用户态缓存转到内存态缓存再转到硬盘
        零拷贝指的是直接从用户态缓存到硬盘,少了中间一步

 * NIO和Netty    
        
        NIO采用字节数组和多个指针来完成数据的读取了存入，Netty是被NIO的封装
        NIO采用Reactor模型,将请求交由Selector来处理,每当有请求时,Selector返回对应的事件来处理请求
        
        BIO时代每个请求都要开辟一个线程,NIO下,只有当请求来时才会用线程处理,等待过程不需要线程等待
        
 * NIO和selector有啥关系？？
        
        ????? 先不做了解
        
 * NIO和BIO的区别
        
        
    
###十三、垃圾收集器
 * 判断对象是否可回收算法
        
        引用计数法：判断当前对象被引用数是否为0,该算法无法回收相互引用的两个对象
        可达性分析算法：通过一些列GC Roots向下搜索,关联不到的对象就应该被回收
        GC Roots包括正在执行方法中存在的对象,方法区中类定义存在静态变量或常量引用的对象
 * 垃圾收集算法
    * 标记-清除算法：
        
            通过判断对象是否存活算法标记出需要回收的对象,之后统一回收
            缺点：
            标记和清除的效率都不高且造成大量不连续空间,保存大内存数据没有足够的空间又将发起新一轮的回收 
    * 复制算法(适合新生代回收,新生代98%的对象都需要回收)：
            
            将内存划分为两块,每次只使用其中的一块,回收时将存活的对象复制到另一块中,然后清除当前快
            缺点：
            总会有一部分内存使用不到, 现在虚拟机新生代采用该算法,只不过分为8:1:1, 每次只有10%的空间不能使用
            复制算法在存活对象较多时就会存在大量的复制
            为什么划分为三部分还不是两部分?
            如果按照9:1, 第一次回收90%的部分存活都放到10%中,第二次只有10%的空间可用了
    * 标记-整理算法(适合老年代回收)：
            
            将存活的对象统一移动到一块连续的内存中,然后清空边界以外的空间
            
 * 垃圾收集器(对垃圾回收算法的实现)
        
        Serial收集器用于回收新生代对象,Serial Old用于回收老年代对象,他们都是单线程的,工作时用户线程只能暂停
        ParNew收集器是Serial的多线程版本,同样工作时用户线程只能暂停
        CMS和G1可以和用户线程并发执行,G1是最前沿的收集器,可以单独管理整个堆区域
        
 * CMS和G1收集器
        
        
###十四、设计模式
 * 工厂模式(抽象工厂模式)
        
        提供统一的接口定义规范,由不同的实现类去实现, 实现子类的灵活切换      
 * 单利模式
        
        提供创建唯一bean对象的模式(内部类的模式)  

 * 观察者模式(发布订阅模式)
        
        监听器就是它的一种实现,将所有对该事件感兴趣的类存储起来,触发时调用。
             
 * 创建者模式
        
        Builder模式, 属性过多时可以自由的组合 
 * 适配器模式
        
        为不同的接口提供一种统一的处理路径,在适配器内部完成适配的逻辑
           
 * 过滤器模式 
        
        通过一组互不关联的逻辑来对一则数据进行过滤      
 * 外观模式
        
        提供一个统一的入口, 在其内部实现多种实现       
 * 代理模式(ProxyFactory)
        
        一个类未另一个类提供代理,使被代理者不直接和代理者接触 
 * 迭代器模式(集合)
        
        集合中的迭代,顺序访问元素
 * 模板模式(AQS)
        
        模版方法定义了算法的步骤，把这些步骤的实现延迟到了子类。
        算法的步骤通过final修饰,需要子类实现的用protected修饰或者抽象方法
 
 * 策略模式(Spring Security)
        
        
###十五、Springboot自动装配原理
 * 自定义Springboot的starter
        
        1. 创建一个普通的Maven项目(创建的项目不可以有启动类, 否则别的项目依赖时找不到类!!!)    
        2. pom文件引入Springboot自动装配的依赖
                <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-autoconfigure</artifactId>
                  <version>2.1.4.RELEASE</version>
                </dependency>
        3. resources目录下新建/META-INF/spring.factories,内容如下：
                org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
                com.tencent.config.LiuFengAutoConfig
           SPI机制,通过指定的目录装配bean,等号前面的K值不要修改,如果使用自定义的K，需要写自己的扫描逻辑。等号后面的V值为我们需要被spring加载的配置文件
           
        4. 定义我们starter的逻辑
                1. 定义配置文件LiuFengProperties, 用以支持从yml文件中设置属性, @ConfigurationProperties(prefix = "demo")，该文件此时不会被Spring加载
                2. 使用@EnableConfigurationProperties(LiuFengProperties.class)来使配置文件被spring管理
                3. 通过Configuration + @Bean的形式配置哪些Bean需要被spring管理,将该配置文件的全路径指定为API中的V值
                4. 我们通过Condition接口来判断这些bean的加载条件,如果用户自己配置了,就不需要自动装配
            
 * 自动装配原理       
          
        1. @SpringBootApplication中的@EnableAutoConfiguration注解引用了AutoConfigurationImportSelector类,该类提供了如下机制  
        1. Spring启动后会根据API机制扫描/META-INF/spring.factories的内容
        2. 加载需要自动装配的bean至Spring
###十六、redis缓存一致性问题如何解决
 * redis缓存一致性问题
        
        redis用作缓存时无法解决缓存一致性问题的,因为redis更新和mysql更新不是原子操作的,总会造成短暂的不一致       
 * 先删除缓存再更新数据库
        
        由于缓存为空,其他线程将数据库的旧数据重新读出再次填入缓存中
 * 先更新数据库再写缓存
        
        读线程取到旧数据,但是更新redis时又晚于写线程,使得redis中的数据依旧没造数据
 * 解决方案1 
 
        延时双删策略
        更新前清空redis的缓存,这样可以保证写线程在写redis之前读线程读到正确的数据
        更新后延迟500ms在删除redis,可以保证防止读线程写redis晚于写线程删redis
        
 * 解决方案2  
        
        基于订阅binlog的同步机制(不做了解)
        
###十七、mysql的索引结构，索引常见的优化原则
 * hash索引和B+tree的区别,为什么选择B+tree
        
        hash索引是一种一对一映射关系的索引,我们可以联想我们的hashmap,但是无法实现范围查找,排序,数据大时hash冲突严重等问题
        B+tree主要就是是实现了范围查找，排序，查找效率稳定才被用作MYSQL索引,同时符合MYSQL以页读取数据的, 只有叶子节点存储数据,保证很少的磁盘IO就可以加载到我们需要的数据
          
 * 聚簇索引、非聚簇索引、覆盖索引、最左原则
        
        聚簇索引: 叶子节点直接存数据
        非聚簇索引: 叶子节点存的是数据所在的地址
        覆盖索引：查询的数据都在索引上,不需要回表
        最左原则：联合索引按照最左原则可以划分为多个索引

 * sql优化
        
        1. 创建索引时需要考虑到分组和排序的字段,通过最左原则创建联合索引
        2. 查询是避免使用select *, 多余的字段会造成索引失效造成覆盖索引失效
        3. 字段最好设置默认值,避免NULL值的出现,因为NULL值可能造成影响索引失效
        4. 过滤条件不要使用模糊查询, 即使使用左侧也必须是确定的
        5. 索引字段必须独立,不可出现表达式，左侧不可以出现表达式,右侧可以
        6. 避免使用not in和 !=
        7. 索引字段的数据类型必须一致,否则索引会失效
        8. 当in和or中的字段为索引时,使用union all,mysql会自动帮我们优化
        9. 当一个字段的取值范围固定且存在大量重复,使用索引的意义不大
        10. 索引的个数控制在最多六个,不然造成更新效率低且占据空间
        11. 尽量使用数值类型,而不是字符串
###十八、做项目时遇到过什么难题，怎么解决的
 * 遇到的问题
 
        项目一：一个是接手一个没参与过的新项目改造,被告知的需求是加了几个小功能,到现场后是与别的系统合并改造
        后端开发人员只有我一个,原系统的开发只能提供咨询,不参与开发。只能通过时间去解决,连续工作22天,每天最早九点下班,最后完成任务。
        期间了解了四个微服务间的关联逻辑, sass不同租户数据库的切换, RocketMQ在项目中的封装和使用, 完成了与两个厂商间的功能对接,配合前端查找前端问题和测试工作等
        该项目的难点就是完全不了解项目的架构以及功能逻辑就要对接用户系统和案件系统的改造,后台开发自始至终只有一个，时间短，在客户地点办公压力大等
        
        项目二：参与一个绩效项目的开发,设计200多张表单的填报,大部分是单表填报,期间被安排去客户现场部署项目,出差一周期间没有开发任务,
        自己开发了一套基于项目的单表增删改查功能,可一件生成实体、DTO、VO、Controller到xml的全部代码,减少了项目后期的开发量。
        支持多表、单表、全表、模糊查询
        设计思路：
        1. 环境变量(通过配置文件读取)：
            数据库信息：url、username、password、scheme、tableName
            字段类型：定义表字段与实体类的类型对应关系
            生成文件位置信息: 生成的路径、包名
            控制信息: 文件是否需要引入Date类型、xml中是否需要生成resultMap等
        
        2. 定义frameWork模板：
            包括Controller、DTO、VO、Entity、Mapper、xml、service、serviceimpl等
        
        3. 加载环境变量、模板信息、返回一个生成器对象
        
        4. 执行生成器的生成方法即可(包装模式)
        
        其实就是获取数据库连接拿到所有的表信息,为模板文件赋值
        
        
###十九、MYBATIS框架的原理
* MYBATIS加载流程
        
        1. 加载并解析mybatis的配置文件,生成SqlSessionFactory和Configuration对象, 我们需要关注的只有两点
            Configuration类中保存了mybatis中所有的配置信息
            MappedStatement：xml中的CURD都会解析为一个MappedStatement节点,保存了节点的全部信息(包括全局信息)
            MapperProxyFactory：Mapper接口的包装类, 会在调用的时候生成一个代理类来调用对应的MappedStatement节点
        2. SqlSessionFactory获取SqlSession,根据标签的ID执行sql操作,具体过程如下:
            DefaultSqlSession为默认的SqlSession实现类,内部含有执行器、事务、数据库连接信息
            找到方法的MappedStatement信息,拼装数据请求数据库(JDBC请求的方式)
            
            
* MYBATIS拦截器原理(通过代理)
        
        MYBATIS中提供了四处可被拦截的对象
        1.Executor             处理器生成时
        2.ParameterHandler     参数
        3.StatementHandler     与数据库的会话
        4.ResultSetHandler     结果
        
                        
* MYBATIS分页采用的内存分页还是物理分页
        
        物理分页,拦截器会修改我们的sql,我们的分页方法可以不用写count()方法,拦截器会帮我们自动生成
        
        
###二十、SpringCloud框架的基本使用

 * 五大组件
        
        Eureka   服务发现组件,用于声明注册中心和服务提供者
        Ribbon   客户端负载均衡(客户端含有注册中心的注册表) 
        Hystrix  断路器(当服务不可用时调用预先备好的结果)
        Zuul     网关(服务统一入口)
        Config   配置服务中心

 * Eureka
        
        注册中心,负责服务的注册和发现,通过集群部署提高可用性。
        
 * Ribbon
        
        客户端负载均衡和跨服务调用。
        
 * Hystrix
        
        断路器、保护系统、控制故障范围。
        
 * Zuul
        
        api网关，路由，负载均衡等多种作用
        
 * Config
 
        
        配置中心
###二十一、Dubbo框架的基本使用

 * Dubbo基本原理 
       
 * 服务暴露原理      
        
###二十二、RocketMQ使用框架的基本使用

 * RocketMQ原理
 
 * RocketMQ如何保证消费不出错
 
###二十三、垃圾回收机制

 *

###二十四、类加载过程
 * 类从被加载到虚拟机内存到清理出虚拟机内存的生命周期
    
        加载--> 验证--> 准备--> 解析--> 初始化--> 使用--> 卸载

 * 加载 
       
       通过一个类的全限定名获取类的二进制字节流
       在方法区生成该类的运行时数据结构(该结构可以获取类的信息)
       生成该数据结构的Class对象作为该类数据结构的入口(用于反射) 
       
       加载的时机为：
       调用类的静态字段或方法
       主线程所在的类
       初始化一个对象(通过反射或者new对象)
 * 验证 
        
        验证类的二进制字节流是否符合虚拟机规范
 * 准备 
        
        为类的静态变量分配初始值,这里只是分配初始值,static int = 12; 这里的赋值为0
        被final修饰的直接赋值(因为该值不会被改变了)
        静态变量和类一样位于方法区
 * 解析 
        
        将常量池中的符号引用改为直接引用。
        符号引用也就是间接引用,指向的是方法区里该类结构
        直接引用指向的是堆区实例的内存地址
 * 初始化 
        
        之执行我们类中的代码,将准备阶段的初始化赋值为代码中定义的值
 * 使用 
        
        使用
 * 卸载 
        
        卸载
###二十五、双亲委派模式和破坏双亲委派

 * 类加载器
        
        类加载的定义：指的是通过一个类的全限定名来获取描述此类的二进制字节流的动作。
        同一个类只有被相同的类加载器加载才能说两个类相等
        每个类加载器都有自己固定扫描的路径,加载类时是通过类的全限定名,如果在其加载路径下没有找到该类,则认为该类加载器无法加载该类
        不同的类加载器加载的类在JVM中是分开的,每个类加载器都有自己的隔离空间
        
 * 默认的三个类加载器
        
        BootstrapClassLoader: 启动类加载器,是虚拟机的一部分,通过C++程序编写, 加载JAVA_HOME/lib包下的指定jar
        
        ExtClassLoader：扩展类加载器,虚拟机外部的,通过JAVA编写, 加载JAVA_HOME/lib/ext包下的指定jar
        
        AppClassLoader: 应用程序类加载器,虚拟机外部的,通过JAVA编写, 加载classpath下的文件
 
               
 * 双亲委派模型
        
        除了启动类加载器以外,任何的类加载器都需要有自己的父类加载器,并不是继承父类而是保存了父类加载器信息(组合模式)
        当一个类加载器加载类时,首先会通过自己的父类去加载,如果直到启动类加载器都无法加载时,他才会去自己加载该类
        
        JAVA中的实现逻辑, 查找当前类加载器是否加载过了,没有的话判父加载器是否为null,如果不为null,重复之前步骤
        当父类加载器为null时,就通过启动类加载器加载,依旧无法加载,抛出一个异常后再由当前类加载器加载
        
 * 打破双亲委派模型
        
        父类加载的需要加载的类位于子类中, 需要向下查找,就这违背了双亲委派模型。JVM团队引入了线程上下文加载器来实现向下查找
        如果没有指定的话就为应用类加载器，并不是说违背了双亲委派就不好,而是一种创新
        SPI机制的实现
        热部署机制的实现
        
 * loadClass()和findClass()的区别
        
        loadClass()表示的父类去加载
        findClass()表示的自己去加载
        
        这也是双亲委派的一个保证,先调用loadClass()通过父类去加载,父类加载不到的话在通过findClass()自己去加载
        
###二十六、SPI
           
 * 什么是SPI
        
        SPI全称Service Provider Interface, 表示服务提供接口, 实现了这么一种机制, 提供了异同统一的调用方式,
        但是具体的实现逻辑由服务提供者自己提供(模板模式),该模式破坏了双亲委派模式
        
###二十七、如何结束一个线程
        
 * 设置退出标识
        
        设置一个标识来结束线程中的循环,但是该方法没办法让处于阻塞中的线程立马退出 
        
 * 中断
        
        我们通过给予一个中断标识的方式来结束线程。该方法的好处是可以是阻塞中的线程立马响应
        中断紧紧只是一个表示,如果线程中没有响应中断,依旧是结束不了的
        
        interrupt() :    设置线程中断标识为true
        isInterrupted() :   返回线程的中断标识
        interrupted() : 返回线程的中断标识,如果为true并清除中断标识
###二十八、ThreadLocal

 * ThreadLocal
        
        线程本地变量,采用的是空间换时间的策略,每个线程都含有一个map,K为ThreadLocal的实例, V为要存的值
        使用完必须删除该K,V, 防止内存泄漏        

###二十九、FutureTask的工作原理



###三十、订单30分钟待付款、已付款、保存已取消记录如何设计
    
 * 方式一：
        
        生成订单数据直接入库,当前状态为待支付
        用户支付成功时修改该订单状态为已支付
        定时刷新数据库修改未支付订单为已取消或者用户获取列表时修改未支付状态为已取消
        
 * 方式二：
        
        生成订单数据直接入库,同时加入DelayQueue,当前状态为待支付
        用户支付成功时修改该订单状态为已支付,DelayQueue中删除该消息
        通过延迟队列修改订单超时的数据更新数据库
        
        
 * 方式三：(RocketMQ顺序消费)(存在消息延迟)
        
        生成订单数据直接入库,同时加入DelayQueue, 发送RocketMQ异步当前状态为待支付
        用户支付成功时修改该订单状态为已支付,DelayQueue中删除该消息，发送RocketMQ异步当前状态为已支付
        通过延迟队列发送取消状态,发送RocketMQ
        
###三十一、RocketMQ

 * RocketMQ的架构设计
        
        Producer：     消息发布角色。通过MQ的负载均衡选择对应的集群队列投递。
        Consumer:      消息消费角色。
        NameServer:    Topic路由注册中心,支持Broker的动态注册与发现。集群中的各个节点是不进行通讯的,保存全部的信息
        BrokerServer： 负责消息的存储、投递和查询等。

 * BrokerServer的架构设计
        
        Remoting Module：  负责处理client的请求(生产者和消费者)
        Client Manager：   负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息
        Store Service：    提供方便简单的API接口处理消息存储到物理硬盘和查询功能。
        HA Service：       高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。
        Index Service：    根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。
 * 如何实现高可用
        
        高可用指的是MQ的部署方式
        
###三十一、http、https、TCP通讯
 
 * 什么是http
        
        http(Hypertext Transfer Protocol)表示超文本传输协议,是一个简单的请求-响应协议。
        运行在TCP之上,指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。
        http的所有传输都是明文传输,是不安全的。
        
 * http工作过程
        
        1.客户与服务器建立连接；
        2.客户向服务器提出请求；
        3.服务器接受请求，并根据请求返回相应的文件作为应答；
        4.客户与服务器关闭连接。      
     
 * http1.1做了什么改变
        在HTTP / 1.1中，引入了保持活动机制，其中连接可以重用于多个请求。
        这样的持久性连接可以明显减少请求延迟，因为在发送第一个请求之后，客户端不需要重新协商TCP 3-Way-Handshake连接
   
 * 什么是https
        
        https(HyperText Transfer Protocol over Secure Socket Layer)表示安全的超文本运输协议    
        在http和TCP中间添加了SSL层实现安全验证
        HTTPS主要由有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。
        服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。
  
 * 对称加密和非对称加密
        
        对称加密：服务器端约定好一个加密方式和秘钥发送个客户端,客户端按照该方式将数据进行加密传输
                 服务器发送加密方式和秘钥的时候是铭文,依旧存在危险
        非对称加密:该加密方式包括一个公钥和一个私钥,一个用于加密一个用于解密
                 服务器发送公钥给客户端,客户端生成一个用于对称解密的秘钥,通过服务器的公钥加密并
                 发送服务器,服务器通过私钥解密,之后通过对称加密进行加密
                 
                 非对称加密实则还是通过对称加密传输的
 * 中间人攻击
        
        对于对称加密来说：中间人可以在第一次传送秘钥时直接获取到加密的秘钥
        对于非对称加密来说: 中间人可以在第一次传输秘钥时偷改公钥和私钥,从而进行拦截
        
        防范中间人攻击：
            
            我们必须保证客户端接收到的公钥是合法的才可以,也就是权威机构颁发的证书
            证书是不可能被替换的,简历连接时会含有服务器的信息,证书中也含有服务器的信息
 * 什么是SSL
        
        https本质是要对http明文传输的内容进行加密和解密。
        
        服务器首先将自己的公钥发给权威机构申请证书。
        服务器在通信后将证书发送给客户端。
        客户端去权威机构验证证书的合法性,验证成功可以获取服务器的公钥
        
 * 什么是TCP
        
        TCP是一个可靠的面向连接的协议，UDP是不可靠或者说无连接的协议。他们都属于传输层
        提供处于网络连接中的两台计算机之间的数据传输

 * 三次握手
        
        
 * 四次挥手        
###三十二、如何实现微信抢红包
   
 * 实现
        
        https://blog.csdn.net/bjweimengshu/article/details/80045958
        
###三十三、ArrayList和LinkedList底层原理

 * ArrayList底层如何实现的、扩容、删除、添加原理
        
        ArrayList的底层是通过数组来存储元素的,数组的特点是查询快,修改慢
        每次添加元素都会进行扩容判断,需要扩容的话变为原来的1.5倍。
        当在集合中间插入和删除元素时,需要通过Arrays去移动元素
        
 * 迭代器实现
        
       迭代器是通过两个变量来实现的,一个变量指向当前元素,一个变量指向下一个元素
 
 * LinkedList底层如何实现的、扩容、删除、添加原理
        
       LinkedList的底层是双向链表,链表的特点是增删快,查询慢
       
 * clone是深拷贝还是浅拷贝
        
       浅拷贝。
       
###三十三、深拷贝和浅拷贝
 
 * 浅拷贝
     
     对象中的引用类型只是拷贝的引用,拷贝前后两个对象的该引用指向的是同一个对象。
     clone()和BeanUtils.copyProperties()都是浅拷贝。
 * 深拷贝
     对象中的引用类型会生成一个新的对象,拷贝前后两个对象的该引用指向的是不同的对象。
     
     1.clone()
        对象实现Cloneable并实现重写clone()
     2.Apache Commons Lang序列化
        User copyUser = (User) SerializationUtils.clone(user);
     3.Gson
            Gson gson = new Gson();
            User copyUser = gson.fromJson(gson.toJson(user), User.class);
     4.jackjson
             使用Jackson序列化进行深拷贝
             ObjectMapper objectMapper = new ObjectMapper();
             User copyUser = objectMapper.readValue(objectMapper.writeValueAsString(user), User.class);
             

###三十四、自定义定时任务线程池(DelayThreadPool)    
   
 * 实现
        
        见DelayThreadPool类
 
 * 原理
        
        主要通过延迟队列实现(DelayQueue), 
        队列中的任务体需要实现Delayed接口,同时需要记录定时的时间
        
###三十五、CPU密集型任务和IO密集型任务
 
 * CPU密集型和IO密集型
        
        CPU密集型指的是需要占用大量的CPU资源,即内存中需要进行大量的运算
        IO密集型指的是需要经常进行IO调用,CPU执行效率很低。
        
        计算密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。
        
###三十六、分布式事务
 
 * 什么是分布式事务
        
        多个服务间的事务问题
        
 * 如何解决分布式事务问题
        
        RocketMQ保证消息最终一致性
 
 * 分布式事务解决方案
        
        TCC方案(try confirm cancel)
             
             try:对各个服务的资源进行检测、锁定、预留。
             confirm:各个服务中执行的实际操作。
             cancel: 一个服务的业务出错,全部回滚。
                
        可靠消息最终一致性方案
            
             基于RocketMQ的分布式事务来实现。
             
        最大努力通知方案
        
 * 两阶段提交(2PC)
        
        第一阶段(预处理阶段)：
            
            协调者向参与的服务发送请求,称之为预处理。
            各个服务执行本地事务,但不会真正的提交到数据库。将执行结果反馈给协调者。
            通过第一阶段协调者可以知道各个服务是否有能力执行该事务。
        
        第二阶段(执行和异常回滚)
            
            当第一阶段全部返回Yes时,协调者向相关服务发起Commit请求。全部正常则执行完毕。
            当第一阶段有服务返回NO时,协调者向相关服务发起RollBack请求。
            
            commit阶段如果有服务失败,还是会造成数据不一致。
            
        问题：
            第一阶段会对资源进行锁定,如果协调者宕机或者处理流程过长,会造成资源浪费
 
 * 三阶段提交(3PC)
        
        三阶段提交协议（3PC）主要是为了解决两阶段提交协议的阻塞问题，
        2pc存在的问题是当协作者崩溃时，参与者不能做出最后的选择。因此参与者可能在协作者恢复之前保持阻塞
        
        改动
            
            1、引入超时机制。同时在协调者和参与者中都引入超时机制。
            2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
            
            在第一阶段只是尝试获取锁,并不会对资源进行真正的锁定。
            
        CanCommit阶段：类似于trylock判断
        PreCommit阶段：锁定资源,加入了超时机制
        DoCommit阶段：提交
        
 * 2PC和3PC的缺陷
        
        都没有解决commit部分成功,部分失败造成的数据不一致问题。
        
 * RocketMQ事务方案
        
        
        
 * seata原理(https://blog.csdn.net/weixiaohuai/article/details/108562777)
        
        使用：
        
            @GlobalTransactional,@Transactional,在事务发起的接口上添加@GlobalTransactional,
            每个服务的方法上加@Transactional注解即可
        三大角色:
            
            TC (Transaction Coordinator) - 事务协调者
            TM (Transaction Manager) - 事务管理器
            RM (Resource Manager) - 资源管理器
            
        过程：
            
            TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；
            XID在微服务调用链路的上下文传播；
            RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；
            TM向TC发起针对XID的全局提交或回滚决议；
            TC调度XID下管辖的全部分支事务完成提交或者回滚请求；
            TC调度XID下管辖的全部分支事务完成提交或者回滚请求；
            
        如何回滚之前数据：
            
            seate会保存每个事务的回滚日志已经行锁,保证该行数据不能被其他事务修改,保证其他服务出错后该服务需要回滚的版本。
            所有事务提交成功后,删除日志和释放行锁。
###三十七、mvc参数接受
  
 * @RequestBody    
 
        当我们不添加@RequestBody时,get和post请求都只会从连接中获取参数
        只有当发送Post请求时,@RequestBody才会生效从body体中获取数据
        
 * @RequestParam(value = "id", required = true)
        
        当我们传递的参数和后台定义的一致时可以直接赋值,当不同时需要使用@RequestParam对应
        
        当后台用对象接受时,只会将属性相同的值赋值
     
 * PathVariable
        
        路径传参数
        
 * post和get的区别
        
        GET产生一个TCP数据包；POST产生两个TCP数据包。
        
        
###接口设计

 * 幂等设计
        
        同一参数多次请求结果一致。
        
        方案:  
            前端先查询版本号,每次根据版本号区更新。
            redis对唯一标志(订单号)进行判断。
 
 * 安全性
        
       https或者对数据自行加密
       
 * 限流机制
        
        通过黑名单等防止接口被攻击。 
        
                
###秒杀系统设计

 * 单一职责
        
        秒杀系统要单独部署在一台服务器上,防止秒杀系统宕机影响其他服务。
 
 * 前端设计
        
        按钮置灰色
        连接通过加盐随机生成
        图片写死不请求后端
 
 * 防刷
        
        前端过滤一部分。
        后端秒杀完毕直接关闭请求。
 
 * 后端设计
        
        数据预热,提前加载至内存。redis超卖回补。
        通过MQ执行
        
###如何保证数据一致性(两个方面)
 
 * 缓存一致性
        
        
 * 分布式事务调用
 
###分布式锁的使用和实现原理
 
 * 
 
 *